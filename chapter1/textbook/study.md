## 1.2 예시 프로그램을 본 소감

코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 작은 단위(함수 등) 재구성한다. 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

`프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.`

잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 나둬도 아무런 문제가 없다. 하지만 그러다 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 한다.

## 1.3 리팩터링의 첫 단계

리팩터링의 첫 단계는 항상 똑같다. 리펙터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다.

여기서 중요한 부분은 테스트 결과를 보고하는 방식이다. 성공/실패를 스스로 판단해 한눈에 보여주는 자가진단 테스트로 만들어 일일이 비교할 필요가 없도록 한다. 최신 테스트 프레임워크를 활용하면 수월하게 진행할 수 있다.

## 1.4 statement() 함수 쪼개기

다음번에 코드를 볼 때 다시 분석하지 않아도 되도록 코드 조각을 함수로 추출한다. 추출함 함수의 이름은 코드가 하는 일을 설명하는 이름을 지어준다. ex) amountFor(aPerformance)

먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다. ex) perf, play, thisAmount
thisAmount는 함수 안에서 값이 바뀌기 때문에 조심해서 다뤄야 한다.

이렇게 수정하고 나면 곧바로 컴파일하고 테스트해서 실수한 게 없는지 확인한다.

함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다. 가장 먼저 변수의 이름을 더 명확하게 바꿔보자. 가령 thisAmount를 result로 변경할 수 있다.

js와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움된다. 그래서 나는 매개변수 이름에 접두어로 타입 이름을 적는데, 지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정관사 a/an을 붙인다.

좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 한다.

### play 변수제거하기

play는 aPerformance에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다. 이러한 임시 변수는 최대한 제거하는 게 좋다. 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지기 때문이다.

이를 해결해주는 리팩터링으로는 임시 변수를 질의 함수로 바꾸기가 있다.

이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 반해 리팩터링한 코드에서는 세 번이나 조회한다. 뒤에서 리팩터링과 성능의 관계를 자세히 설명하겠지만, 일단 지금 확인한 바로는 이렇게 변경해도 성능에 큰 영향은 없다. 설사 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.

지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다.

### format 변수 제거하기

임시 변수는 자신이 속한 루틴에서만 의미가 있어서 길고 복잡해지기 쉽다. 다음으로 할 리팩터링은 이런 변수들을 제거하는 것이다. 그중에서 format이 가장 만만해 보인다. format은 임시 변수에 (함수 포인터처럼) 함수를 대입한 형태인데, 나는 함수를 직접 선언해 사용하도록 바꾸는 편이다.

format은 이 함수가 하는 일을 충분히 설명해주지 못한다. formatAsUSD라고 하기에는 또 너무 장황하다. 이 함수의 핵심은 화폐 단위 맞추기다. 그래서 그런 느낌을 살리는 이름을 골라 다음과 같이 함수 선언 바꾸기를 적용했다.

이름짓기는 중요하면서도 쉽지 않은 작업이다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다. 물론 단번에 좋은 이름을 짓기는 쉽지 않다. 따라서 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다. 흔히 코드를 두 번 이상 읽고 나서야 가장 적합한 이름이 떠오르곤 한다.

### volumeCredits 변수 제거하기

반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다. 이처럼 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다.

경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다. 똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문이다. 또한 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 해도 성능 차이를 체감할 수 없다.

하지만 '대체로 그렇다'와 '항상 그렇다'는 엄연히 다르다. 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 그런 경우라도 나는 개의치 않고 리팩터링한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다. 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다. 이 과정에서 리팩터링된 코드를 예전으로 되돌리는 경우도 있지만, 대체로 리팩터링 덕분에 성능 개선을 더 효과적으로 수행할 수 있다. 결과적으로 더 깔끔하면서 더 빠른 코드를 얻게 된다.

따라서 리택터링으로 인한 성능 문제에 대한 내 조언은 '특별한 경우가 아니라면 일단 무시하라'라는 것이다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

또 하나, volumeCredits 변수를 제거하는 작업의 단계를 아주 잘게 나눴다는 점에도 주목하자. 다음과 같이 총 네 단계로 수행했으며, 각 단계마다 커마일-테스트하고 로컬 저장소에 커밋했다.

1. 반복문 쪼개기로 변수 값을 누적시키는 부분을 정리한다.
2. 문장 슬라이드하기로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. 함수 추출하기로 적립 포인트 계산 부분을 별도 함수로 추출한다.
4. 변수 인라인하기로 volumeCredits 변수를 제거한다.

솔직히 나라고 해서 항상 단계를 이처럼 잘게 나누는 것은 아니지만, 그래도 상황이 복잡해지면 단계를 더 작게 나누는 일을 가장 먼저 한다. 특히 리팩터링 중간에 테스트가 실패하고 원인을 바로 찾지 못하면 가장 최근 커밋으로 돌아가서 테스트에 실패한 리팩터링의 단계를 더 작게 나눠 다시 시도한다. 이렇게 하면 문제를 해결할 수 있다. 커밋을 자주 했기 때문이기도 하고, 코드가 복잡할수록 단계를 작게 나누면 작업 속도가 빨라지기 때문이다.

## 1.6 계산 단계와 포맷팅 분리하기

statement를 HTML 버전으로 옮기면서, 중첩 함수들 때문에 복잡해질 수 있다. 이럴 때 가장 선호하는 방식은 단계 쪼개기다. 로직을 다음 두 단계로 나눌 수 있다. 첫 단계에서는 statement()에 필요한 데이터를 처리하고, 다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 하자. 다시 말해 첫 번째 단계에서는 두 번째 단계로 전달한 중간 데이터 구조를 생성하는 것이다.

## 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨

처음보다 코드량이 부쩍 늘었다. 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다. 이렇게 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다. 간결함이 지헤의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다. 모듈화한 덕분에 계산 코드를 중복하지 않고도 HTML 버전을 만들 수 있다.

## 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

한편 계산기 인스턴스를 반환하는 방식과 각각의 출력 값으로 직접 계산하는 방식 중 하나를 선택할 때 나는 결과로 나온 데이터 구조를 누가 사용하는가를 기준으로 정한다. 이번 예에서는 다형성 계산기를 사용한다는 사실을 숨기기보다는 중간 데이터 구조를 이용하는 방법을 보여주는 편이 낫다고 생각해서 이렇게 작성했다.

## 1.10 마치며

리팩터링은 대부분 코드가 하는 일을 파악하는 데서 시작한다. 그래서 코드를 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행한다.

좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
