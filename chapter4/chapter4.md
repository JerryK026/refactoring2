# 테스트 구축하기

리팩터링을 제대로 하려면 견고한 test suite가 뒷받침돼야 한다.

## 4.1 자가 테스트 코드의 가치

`모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.`

`테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.`

테스트 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 나는 기능을 추가해야할 때 테스트부터 작성한다. 테스트를 작성하다 보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다. 게다가 코딩이 완료되는 시점을 정확하게 판단할 수 있다. 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.

이처럼 테스트부터 작성하는 습관을 바탕으로 만들어진 것이 `테스트 주도 개발`(TDD)다.

1. 통과하지 못할 테스트를 작성한다.
2. 테스트를 통과하게끔 코드를 작성한다.
3. 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을 거친다.

이 과정을 짧은 주기로 반복한다.

기존 코드를 검증하는 테스트를 작성하고 통과했을 지라도, 내 코드에 일시적으로 오류를 넣어놓고 이번에도 통과하는지(테스트가 제대로 작성됐는지) 확인 해본다.

## 4.3 첫 번째 테스트

`실패해야 할 상황에서는 반드시 실패하게 만들자.`

`자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.`

픽스처 : 테스트에 필요한 데이터와 객체

여기서 사용한 테스트 프레임워크는 `Mocha`이고 assertion 라이브러리(픽스처 검증 라이브러리)는 `chai`를 사용했다.

assert를 선호하지만 js를 다룰 때는 expect를 주로 사용한다.

## 4.4 테스트 추가하기

**_테스트는 위험 요인을 중심으로 작성한다._** 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는 데 있다. 따라서 단순히 필드를 읽고 쓰기만 하는 접근자 등은 굳이 테스트할 필요가 없다. 테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽다.

`완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.`

```jsx
this.beforeEach(function () {
  const asia = new Province(sampleProvinceData());
});
```

위 코드에서 const asia를 밖으로 뺴놓지 않는 이유는 테스트 관련 버그 중 가장 지저분한 유형인 '테스트끼리 상호작용하게 하는 공유 픽스처'를 생성하는 원인이 되기 때문이다. js의 const는 asia 객체의 내용이 아니라 asia를 가리키는 참조가 상수임을 뜻한다. 나중에 다른 테스트에서 이 공유 객체의 값을 수정하면 이 픽스처를 사용하는 또 다른 테스트가 실패할 수 있다. 즉, 테스트를 실행하는 순서에 따라 결과가 달라질 수 있다.

따라서 beforeEach 구문은 각각의 테스트 바로 전에 실행되어 asia를 초기화하기 때문에 모든 테스트가 자신만의 새로운 asia를 사용하게 된다. 이처럼 개별 테스트를 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있어 결과를 예측할 수 없는 경우를 예방할 수 있다. 이 때문에 테스트가 눈에 띄게 느려지는 일은 거의 없다.

정말 느려질 때는 공유 픽스처를 사용하기도 하지만, 이럴 때는 어떠한 테스트도 픽스처 값을 변경하지 못하도록 주의해야 한다. 불변임이 확실한 픽스처는 공유하기도 한다.

## 4.5 픽스처 수정하기

실전에서는 사용자가 값을 변경하며 픽스처의 내용도 수정되는 경우가 흔하다. 이러한 수정 대부분은 세터에서 이뤄지는데, 세터는 보통 테스트하지 않지만 Producer의 production() 세터는 좀 복잡한 동작을 수행하기 때문에 테스트할 필요가 있다.

테스트 패턴으로는 beforeEach 블록에서 '설정'한 표준 픽스처를 취해, 테스트를 '수행'하고, 이 픽스처가 일을 기대한 대로 처리했는지를 '검증'한다.

이 세 가지 단계가 한 테스트 안에 모두 담겨 있을 수도 있고, 초기 준비 작업 중 공통되는 부분을 beforeEach와 같은 표준 설정 루틴에 모아서 처리하기도 한다.

픽스처를 제거해 테스트들이 서로 영향을 주지 못하게 하는 '해체' 단계도 있는데 명시적으로 언급하지 않을 때가 많다.

일반적으로 it 구문 하나당 검증도 하나씩만 하는 게 좋다. 앞쪽 검증을 통과하지 못하면 나머지 검증은 실행해보지 못하고 테스트가 실패하기 때문이다. 한 테스트로 묶어도 문제되지 않을 정도로 두 속성이 밀접하다고 판단될 때는 묶기도 한다.

## 4.6 경계 조건 검사하기

`문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.`

에러와 실패를 구분하지 않는 프레임워크도 있다. 모카도 그렇다.

오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면 `어서션 추가하기`를 적용해서 오류가 최대한 빨리 드러나게 하자.

`어차피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.`

테스트를 너무 많이 작성하다 보면 오히려 의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다. 따라서 위험한 부분에 집중하는 게 좋다.

- 코드에서 처리 과정이 복잡한 부분을 찾아보자.
- 함수에서 오류가 생길만한 부분을 찾아보자.

## 4.7 끝나지 않은 여정

이 장에서 보여준 테스트는 unit test에 해당한다. 이는 작은 영역만을 대상으로 빠르게 실행되도록 설계된 테스트를 말한다. 단위 테스트는 자가 코드의 핵심이자, 자가 테스트 시스템은 대부분 단위 테스트가 차지한다. 물론 이 밖에도 다양한 테스트가 있다.

한 번에 완벽한 테스트를 갖출 순 없으므로, 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다. 기존 테스트가 충분히 명확한지, 테스트 과정을 더 이해하기 쉽게 리팩터링할 수는 없는지, 제대로 검사하는지 등을 확인한다. **_버그를 발견하는 즉시 발견한 버그를 명확히 잡아내는 테스트부터 습관을 들이자._** 또한 그 버그와 테스트를 계기로 테스트 스위트에 또 다른 구멍은 없는지까지 살펴본다.

`버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자.`

테스트 스위트가 충분한지를 평가하는 기준은 주관적이므로 판단하기 어렵다.
