# 리팩터링 원칙

## 2.1 리팩터링 정의

> 리팩터링: [명사] 소트프웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

리펙터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 리팩터링하는 동안에는 코드가 항상 정상작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

리팩터링 전과 후는 코드가 똑같이 동작해야 한다. 그렇다고 완전히 똑같다는 말은 아니고, 성능이 달라질 수도 있고 모듈의 인터페이스가 바뀔 수도 있다. 사용자 관점에서 달라지는 점이 없어야 한다. 한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

## 2.2 두 개의 모자

소트웨어를 개발할 때 목적이 '기능 추가'냐 아니면 '리팩터링'이냐를 명확히 구분해 작업한다.

소프트웨어를 개발하는 동안 이 두 가지 모자를 자주 바꿔쓰게 된다. 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들면, 잠시 모자를 바꿔 쓰고 리팩터링한다. 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다.

전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

## 2.3 리팩터링하는 이유

#### 리팩터링하면 소프트웨어 설계가 좋아진다.

코드만 봐서는 설계를 파악하기 어려워진다. 규칙적인 리팩터링은 코드의 구조를 지탱해 준다.

같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 중복 제거가 되지 않았기 때문이다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니지만, 코드량이 줄면 수정하는 데 드는 노력이 줄고, 이해해야 할 코드량도 줄어들며 언제나 고유한 일을 수행핟록 보장할 수도 있다.

#### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

#### 리팩터링하면 버그를 쉽게 찾을 수 있다.

#### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

이 효과를 `설계 지구력 가설`이라고 부른다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

## 2.4 언제 리팩터링해야 할까?

저자는 거의 한 시간 간격으로 리팩터링한다고 한다. 그러다 보니 작업 흐름에 리팩터링을 녹이는 방법이 여러 가지임을 알게 됐다고 한다.

> 3의 법칙
>
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만,) 일단 계속 한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.
>    야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)'으로 기억하자.

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾아 해결한다.

버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다. 이처럼 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

저자는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다.

리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다.

#### 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 이때 약간 절충을 해야 한다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 `쓰레기 줍기 리팩터링`이다.

#### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다. 이를 위한 일정이 따로 있는 것은 아니고 기능을 추가하거나 버그를 잡는 등 프로그래밍 과정에 자연스럽게 하는 것이다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

리팩터링은 과거에 저지를 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 보기 싫은 코드 뿐만 아니라 잘 작성된 코드 또한 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다.) 그런 다음 쉽게 수정하자.

계획된 리팩터링이 무조건 나쁘다는 말은 아니다. 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다. 하지만 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

git에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다. 이렇게 할 때의 큰 장점은 두 가지 활동을 구분해 별개로 검토하고 승인할 수 있다는 것이다. 하지만 저자는 이 견해에 완전히 동의하지는 않는다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많아 굳이 나누는 것은 시간 낭비일 수 있고, 해당 리팩터링을 하게 된 맥락 정보가 사라져 왜 그렇게 수정했는지 이해하기 어려워진다.

따라서 리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 팀에 적합한 방식을 실험을 통해 찾아내야 한다.

#### 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분 내지 몇 시간 내에 끝나지만, 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다. (ex. 라이브러리 교체, 컴포넌트 분리, 의존성 정리 등)

저자는 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 리팩터링해도 모든 기능이 항상 올바르게 작동한다는 점을 이용한 것이다.

예를 들어 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련해 라이브러리를 쉽게 교체할 수 있도록 한다.

#### 코드 리뷰에 리팩터링 활용하기

내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수도 있고, 다른 사람의 아이디어를 얻을 수도 있기 때문에 저자는 기회가 닿는 대로 코드 리뷰를 한다.

리팩터링은 개선안들을 제시하는 데서 그치지 않고, 즉시 구현해볼 수 있기 때문에 코드 리뷰 결과를 더 구체적으로 도출하는 데 도움을 줄 수도 있다.

pr을 이용한 방식은 맥락을 설명하기 어렵고, 작성자도 리뷰어의 변경 의도를 제대로 이해했는지 확인하기 어렵다. 가장 좋은 방법은 `짝 프로그래밍`이다.

#### 관리자에게는 뭐라고 말해야 할까?

관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설득할 수 있다. 하지만 그렇지 않은 대부분의 관리자와 고객들에게는 '리팩터링한다고 말하지 말라'.

#### 리팩터링하지 말아야 할 때

지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 마찬가지다.

## 2.5 리팩터링 시 고려할 문제

#### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

그렇다고 해도 상황에 맞게 조율해야 한다. 예컨대 (대대적인) 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 이럴 때는 프로 개발자로서 가진 경험을 잘 발휘해 결정한다. 이럴 때 균형점을 잡는 방법을 설명하기는 쉽지 않고, 정량화하기는 더더욱 어렵다.

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 `클린 코드`나 `바람직한 엔지니어링 습관`처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않고, 경제적인 이유로 개발 시간을 단축하고자 하는 것임을 명심해야 한다.

#### 코드 소유권

함수를 호출하려는 코드의 소유자가 다른 팀이라 나에게는 쓰기 권한이 없을 수도 있고, 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지는 고사하고, 실제로 쓰이거나 하는지조차 모를 수도 있다. 이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 '공개된 인터페이스'에 속한다.

코드 소유권이 나뉘어 있으면 클라이언트에 영향을 주지 않고는 원하는 형태로 변경할 수 없기 때문에 리팩터링에 방해가 된다. 따라서 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데는 반대하고, 코드 소유권을 팀에 두고 팀 멤버라면 누구나 코드를 수정할 수 있게 하는 걸 선호한다.

#### 브랜치

릴리스할 때만 마스터에 통합해 사용하는 브랜치 방식은 기능이 추가될 때마다 버전을 명확히 할 수 있고, 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있다는 장점이 있다.

하지만 이런 기능 브랜치 방식은 독립 브랜치로 작업하는 기간이 길어질수록 마스터로 통합하기 힘들다. 따라서 마스터를 개인 브랜치로 수시로 리베이스하거나 머지하더라도, 여러 기능 브랜치에서 동시 개발할 때 해결하기가 어렵다.

저자는 통합과 머지를 확실히 구분한다.
머지 : 마스터를 브랜치로 머지하는 작업은 브랜치만 바뀌고 마스터는 그대로다.
통합 : 개인 브랜치에서 마스터를 풀해서 작업한 결과를 다시 마스터에 푸시한다.

머지가 복잡해지면 기능별 브랜치들이 독립적으로 개발되는 기간이 기하급수적으로 늘어난다. 따라서 팀원이 하루에 최소 1 번은 마스터와 통합해야 한다고 주장하는데, 이를 CI(Continuous Integration)라고 한다. 이럴 경우 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져 머지의 복잡도를 낮출 수 있다.

하지만 CI를 적용하기 위해선 마스터를 건강하게 유지하고, 큰 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능 토글을 적용해 완료되지 않은 기능이 시스템 전첼르 망치지 않도록 해야 한다.

CI는 리팩터링과 궁합이 아주 좋다. 켄트 백은 CI와 리팩터링을 합쳐 익스트림 프로그래밍(XP. eXtreme Programming)을 만들었다.

기능별 브랜치를 사용하면 안 된다는 말은 아니고, 자주 통합하면 문제가 발생할 가능성을 크게 줄일 수 있다는 말이다.

#### 테스팅

리팩터링의 가장 큰 특징은 프로그램의 겉보기 동작은 똑같이 유지된다는 점이다. 하지만 실수록 저지른다면 가능한 빨리 오류를 잡아야 한다. 이를 위해 코드의 다양한 측면을 검사하는 test suite가 필요하고, 빠르게 실행시킬 수 있어야 수시로 테스트하는데 부담이 없다.

이 말은 즉슨 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다는 뜻이다.

테스트를 작성하면 노력을 기울여야 한다는 것은 사실이지만, 기능 추가나 리팩터링을 버그에 대한 불안감 없이 코드를 작성할 수 있다.

#### 레거시 코드

레거시 코드를 리팩터링할 때 또한 테스트 코드는 도움이 된다. 추천 저서는 `레거시 코드 활용 전략`이다. 주요 내용을 한 마디로 표현하면 `프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다`는 것이다.

테스트를 갖추더라도 복잡한 레거시 코드를 리팩터링하기는 어렵다. 저자가 선호하는 방식은 서로 관련된 부분끼리 나눠 하나씩 공략하는 것이다. 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다.

#### 데이터베이스

db는 리팩터링하기 어려운 영역이였으나 최근은 `진화형 데이터베이스 설계`와 `데이터베이스 리팩터링 기법`을 적용하면 수월하게 할 수 있다. 이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.

db 리팩터링은 프로덕션 환경에 여러 단계로 나눠 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이방식은 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
