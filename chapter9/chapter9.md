# 데이터 조직화

하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳으므로 `변수 쪼개기`를 적용해 용도별로 분리한다. 변수 이름을 짓는 일은 까다로우면서 중요하기 때문에 `변수 이름 바꾸기`와는 반드시 친해져야 한다. 한편, `파생 변수를 질의 함수로 바꾸기`를 활용해 변수 자체를 완전히 없애는 게 가장 좋은 해법일 때도 있다.

참조인지 값인지 헷갈려 문제가 될 때 둘 사이를 전환할 때는 `참조를 값으로 바꾸기`와 `값을 참조로 바꾸기`를 사용한다.

코드에 의미를 알기 어려운 리터럴이 보이면 `매직 리터럴 바꾸기`로 명확하게 바꿔준다.

## 9.1 변수 쪼개기

변수는 중간중간 값을 저장하는 용도로 사용하기도 하지만, 긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰인다. 이런 변수에는 값을 단 한 번만 대입해야 한다. 대입이 두 번 이상 이뤄진다면 여러 역할을 수행한다는 신호다. 역할이 둘 이상인 변수는 예외 없이 쪼개야 한다.

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
   - 이후의 대입이 항상 i = i + <무언가> 형태라면 수집 변수이므로 쪼개면 안 된다. 수집 변수는 총합 계산, 문자열 연결, 스트림에 쓰기, 컬렉션에 추가하기 등의 용도로 흔히 쓰인다.
2. 가능하면 이때 불변으로 선언한다.
3. 이 변수에 두 번쨰로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트한다.
6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.

## 9.2 필드 이름 바꾸기

데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다.

| 데이터 테이블 없이 흐름도만 보여줘서는 나는 여전히 혼란스러울 것이다. 하지만 데이터 테이블을 보여준다면 흐름도는 웬만해선 필요조차 없을 것이다. 테이블만으로 명확하기 때문이다. - 프레드 브룩스

데이터 구조가 중요한 만큼 반드시 깔끔하게 관리야 한다.

이 과정에서 레코드의 필드 이름을 바꾸고 싶을 수도 있는데, 클래스에서도 마찬가지다. 게터와 세터 메서드는 클래스 사용자 입장에서는 필드와 다를 바 없다. 따라서 게터와 세터 이름 바꾸기도 레코드 구조체의 필드 이름 바꾸기와 똑같이 중요하다.

1. 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요 없다.
2. 레코드가 캡슐화되지 않았다면 우선 레코드를 캡슐화한다.
3. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.
4. 테스트한다.
5. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 함수 선언 바꾸기로 변경한다.
6. 접근자들의 이름도 바꿔준다.

## 9.3 파생 변수를 질의 함수로 바꾸기

가변 데이터는 SW에 문제를 일으키는 가장 큰 골칫거리에 속한다. 가변 데이터를 완전히 배제하기란 현실적으로 불가능할 때가 많지만, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.

효과가 좋은 방법으로 값을 쉽게 계산할 수 있는 변수들을 모두 제거할 수 있다. 의미를 더 분명히 드러내는 경우도 있고 변경된 값을 깜빡하고 결과 변수에 반영하지 않는 실수를 막아준다.

피연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변으로 만들 수 있다. 새로운 데이터 구조를 생성하는 변형 연산이라면 계산 코드를 대체할 수 있더라도 그대로 두는 것이 좋다.

변형 연산에는 두 가지가 있다. 첫째, 데이터 구조를 감싸며 그 데이터에 기초하여 계산할 결과를 속성으로 제공하는 객체다.

둘째, 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수다. 소스 데이터가 가변이고 파생 데이터 구조의 수명을 관리해야 하는 상황에서 객체를 사용하는 편이 유리하다.

반면 소스 데이터가 불변이거나 파생 데이터를 잠시 쓰고 버릴 거라면 어느 방식을 써도 상관없다.

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
   - 필요하면 변수 캡슐화하기를 적용하여 어서션이 들어갈 장소를 마련해준다.
4. 테스트한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트한다.
7. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.

## 9.4 참조를 값으로 바꾸기

객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다. 참조로 다루는 경우 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.

필드를 값으로 다루면 내부 객체의 클래스를 수정해 값 객체로 만들 수 있다. 값 객체는 불변이기 때문에 특히 활용하기 좋다. 관리할 필요가 없기 때문이다.

1. 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.
2. 각각의 세터를 하나씩 제거한다.
3. 이 값 객체의 필드들을 사용하는 동치성 비교 메서드를 만든다.
   - 대부분의 언어는 이런 상황에 사용할 수 있도록 오버라이딩 가능한 동치성 비교 메서드를 제공한다. 동치성 비교 메서드를 오버라이드할 때는 보통 생성 메서드도 함꼐 오버라이드해야 한다.

## 9.5 값을 참조로 바꾸기

하나의 데이터 구조 안에 논리적으로 똑같은 제3의 데이터 구조를 참조하는 레코드가 여러 개 있을 떄가 있다. 예를 들어 주문 목록에 같은 고객이 요청한 주문이 여러 개 섞여 있을 수 있다. 이때 고객을 값으로 다루면 고객 데이터가 각 주문에 복사되고, 참조로 다룬다면 여러 주문이 단 하나의 데이터 구조를 참조하게 된다.

논리적으로 같은 데이터를 물리적으로 복제해 사용하는 것은 별달리 문제가 없는 경우가 많아 흔히 사용된다. 그러나 그 데이터가 갱신되는 경우 문제가 발생한다. 모든 복제본을 빠짐없이 갱신해야 하기 때문이다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다.

값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재하게 되는데, 그러면 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요해진다. 각 엔티티를 표현하는 객체를 한 번만 만들고, 객체가 필요한 곳에서는 모두 이 저장소로부터 얻어 쓰는 방식이 된다.

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다(이미 있다면 생략).
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트한다.

## 9.6 매직 리터럴 바꾸기

매직 리터럴이란 소스 코드에 등장하는 일반적인 리터럴 값을 말한다. 예를 들면 상수가 있다.

일반적으로는 해당 값이 쓰이는 모든 곳을 적절한 이름의 상수로 바꿔주는 방법이 가장 좋다. 혹은 비교 로직에 사용하는 방법이 있다. aValue === MALE_GENDER 보다는 isMale(aVlue)라는 함수 호출로 바꾸는 쪽이 낫다.

상수를 과용하는 경우도 있다. 의미 전달에 차이가 없는 경우나 함수 하나에서만 쓰이고 그 함수가 맥락 정보를 충분히 제공하여 헷갈릴 일이 없다면 상수로 바꿔 얻는 이득이 줄어든다.

1. 상수를 선언하고 매직 리터럴을 대입한다.
2. 해당 리터럴이 사용되는 곳을 모두 찾는다.
3. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다.

이 리팩터링이 제대로 되었는지 테스트하기 위해선 상수의 값을 바꾸고, 관련 테스트 모두가 바뀐 값에 해당하는 결과를 내는지 확인하는 방법이 있다.
