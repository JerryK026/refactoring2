# 3. 코드에서 나는 악취

# 1. 기이한 이름

- 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두가지 중 하나
- 우리가 가장 많이 사용하는 리팩토링에도 이름바꾸기가 포함되어 있다.
    - **함수 선언 바꾸기**
    - **변수 이름 바꾸기**
    - **필드 이름 바꾸기**
- 이름만 잘 지어도 나중에 문맥 파악하기에 용이하다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 있따.

# 2. 중복 코드

- 똑같은 코드 구조가 반복된다면, 하나로 통합하여 더 나은 프로그램을 만들 수 있는지 봐야함.
- 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 한다.
- 예)
    - 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.
    - **문장 슬라이드**하기로 비슷한 부분을 한 곳에 모을 수는 없는지
    - 각자 따로 호출되지 않도록 **메서드 올리기**를 적용해 부모로 옮긴다.

# 3. 긴 함수

- 짧은 함수의 효과
    - 간접 호출
    - 이해, 공유, 선택
- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
- 함수를 짧게 만드는 작업의 99% 는 함수 추출하기 **(6.1장)** 가 차지
- 함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.
    - 임시 변수를 질의 함수로 바꾸기 **(7.4장)**
    - 매개변수 객체 만들기 **(6.8장)**
    - 객체 통째로 넘기기 **(11.4장)**
    - 함수를 명령으로 바꾸기 **(11.9장)**
- 추출할 코드 덩어리는 주석을 참고하는 것. 코드가 한 줄이어도 따로 설명할 필요가 있다면, 함수로 추출하는 것이 좋다.
- 조건문
    - 조건문 분해하기 **(10.1)**
    - switch-case 함수 추출하기 **(6.1)**
    - 같은 조건을 기준으로 나뉘는 switch 문이 여러개라면 → 조건부 로직을 다형성으로 바꾸기 **(10.4)**
- 반복문
    - 반복문 쪼개기
    
# 4. 긴 매개변수 목록

- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 때
    - **매개변수를 질의 함수로 바꾸기 (11.5)**
- 데이터 구조에서 값을 뽑아 별개의 매개변수를 전달할 때
    - **객체 통째로 넘기기 (11.4)**
- 항상 함께 전달되는 매개변수
    - **매개변수 객체 만들기 (6.8)**
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수
    - **플래그 인수 제거하기 (11.3)**
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단
    - 특히 여러 개의 함수가 특정한 매개변수들의 값을 공통으로 사용할 때
    - **여러 함수를 클래스로 묶기 (6.9)**

# 5. 전역 데이터

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 매커니즘이 없다.
- **변수 캡슐화하기 (6.6)**
    - 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용
    - 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
    - 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 중요

# 6. 가변 데이터

- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 겨우가 있다.
- 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, **데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환**한다는 개념을 기본으로 삼음.
- **변수 캡슐화하기 (6.6)**
    - 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록
- **변수 쪼개기 (9.1)**
    - 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
- **문장슬라이드하기(8.6) / 함수 추출하기 (6.1)**
    - 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- **질의 함수와 변경 함수 분리하기 (11.1)**
    - 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
- **세터 제거하기 (11.7)**
    - 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움이 될 수 있다.
- **파생 변수를 질의 함수로 바꾸기 (9.3)**
- **여러 함수를 클래스로 묶기(6.9), 여러 함수를 변환 함수로 묶기 (6.1)**
    - 변수를 갱신하는 코드들의 유효범위를 제한한다.
- **참조를 값으로 바꾸기 (9.4)**
    - 내부 필드를 직접 수정하지 말고, 구조체를 통째로 교체하는 편이 낫다
    

# 7. 뒤엉킨 변경

- **단계 쪼개기 (6.11)**
    - 다음 맥락에 필요한 데잍어를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
- **함수 옮기기 (8.1)**
    - 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모음
- **함수 추출하기 (6.1)**
    - 여러 맥락의 일에 관여하는 함수가 있다면 옮기기전에 함수 추출하기 부터 수행
- **클래스 추출하기 (7.5)**
    - 모듈이 클래스라면 클래스 추출하기

# 8. 산탄총 수술

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- **함수 올기기 (8.1), 필드 옮기기 (8.2) 로 한 모듈에 묶어두면 좋다.**
- **여러 함수를 클래스로 묶기 (6.9)**
    - 비슷한 데이터를 다루는 함수가 많다면
- **여러 함수를 변환 함수로 묶기 (6.10)**
    - 데이터 구조를 변환하거나 보강하는 함수들에는
- **단계 쪼개기 (6.11)**
    - 묶은 함수들의  출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면
- **함수 인라인하기(6.2), 클래스 인라인하기 (7.6)**
    - 인라인 리팩터링으로 하나로 합치는 것
    - 메서드나 클래스가 비대해지기는 하지만 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있다.

# 9. 기능 편애

- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 나타난다.
    - **함수 옮기기(8.1)** 를 통해 근처로 옮겨준다.
    - **함수 추출하기(6.1), 함수 옮기기 (8.1)**를 통해 그 부분만 독립함수로 빼낸 다음 원하는 모듈로 보내준다.
- 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 ㄴ옮긴다.

# 10. 데이터 뭉치

- 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기 (7.5)로 하나의 객체로 묶는다.
- 매게변수 객체 만들기 (6.8) 객체 통째로 넘기기(11.4)를 적용해서 매개변수 수를 줄여본다.

# 11. 기본형 집착

- 프로그래머 중에서는 자신에게 주어진 문제에 딱 맞는 기초 타입 (화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.
- 금액을 그냥 숫자형으로 계산하거나, 물리량을 계산할 때도 밀리미터나 인치같은 단위를 무gksek.
- 기본형을 객체로 바꾸기 (7.3)
- 타입 코드를 서브 클래스로 바꾸기 (12.6)
- 조건부 로직을 다형성으로 바꾸기 (10.4)
- 클래스 추출하기 (7.5), 매개변수 객체 만들기 (6.8)

# 12. 반복되는 switch 문

- 코드에 등장하는 switch 문은 모조리 조건부 로직을 다형성으로 바꾸기 (10.4)로 없애야할 대상

# 13. 반복문

- 반복문을 파이프라인으로 바꾸기 (8.8) 을 적용해서 처리
- 필터나 맵 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.
- 예시) 리팩토링 전

```jsx
const names=[];
for (const i of input){
	if(i.job===="programmer"){
		names.push(i.name);
	}
}
```

- 예시) 리팩토링 후

```jsx
const names = input 
							.filter(i=>i.job==="programmer")
							.map(i=>i.name)
```

- 대표적인 연산은 map 과 filter
- map 은 함수를 사용해 입력 컬렉션의 각 원소를 변환하고
- filter 는 또 다른 함수를 사용해 입력 컬렉션을 필터링해 부분집합을 만든다.

### 절차

1. 반복문에서 사용하는 컬렉션을 가르키는 변수를 하나 만든다.
2. 반복문의 첫 줄부터 시작해서, 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다.
3. 반복문 삭제

# 14. 성의 없는 요소

- 함수 인라인하기 (6.2), 클래스 인라인하기 (7.6) 로 처리
- 상속을 사용했다면 계층 합치기 (12.9) 적용

# 15. 추측성 일반화

- ‘나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드
- **계층 합치기(12.9)**
    - 하는 일이 거의 없는 추상 클래스는 계층 합치기로 제거
- **함수 인라인하기 (6.2), 클래스 인라인하기 (7.6)**
    - 쓸데 없이 위임하는 코드는 위의 방법으로 삭제
- **함수 선언 바꾸기 (6.5)**
    - 본문에서 사용되지 않는 매개변수는 위의 방법으로 삭제
- 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔이 볼수 있다.
- 이런 코드를 발견하면 테스트 케이크부터 삭제한 뒤에 **죽은 코드 제거하기(8.9)** 로 날려버릴 수 있다.

# 16. 임시 필드

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스
- **클래스 추출하기 (7.5)**
    - 덩그러니 떨어져 있는 필드들을 발견하면
- **함수 옮기기 (8.1)**
    - 임시 필드와 관련된 코드를 모조리 새 클래스에 몰아넣는다.
- **특이 케이스 추가하기 (10.5)**
    - 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.
    

# 17. 메시지 체인

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드.
- 위임 숨기기 (7.7)
- 함수 추출하기(6.1) 로 결과 객체를 사용하는 코드 일부를 빼낸 다음
- 함수 옮기기(8.1)로 체인을 숨길 수 있는지 살펴보면 된다.

```jsx
managerName= aPerson.department.manager.name; // 메시지 체인의 전형적인 예.

report = `${managerName}`께 

console.log(report);
```

- 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.

```jsx
console.log(reportAutoGenerator.report(aPerson));
```

# 18. 중개자

- 캡슐화
    - 외부로부터 세부사항을 숨겨준다.
    - 캡슐화 과정에서는 위임이 자주 활용된다.
- 하지만 지나치면 문제가됨.
- 중개자 제거하기 (7.8)
- 함수 인라인 하기

# 19. 내부자 거래

- 모듈 사이의 데이터 거래를 최소로 줄이고 투명하게 처리해야 한다.
- 함수 옮기기 (8.1), 필드 옮기기 (8.2)
    - 사적으로 처리하는 부분을 줄인다.
- 위임 숨기기 (7.7)
    - 여러 모듈이 같은 관심사를 공유한다면, 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로들거나, 위임숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
- 서브 클래스를 위임으로 바꾸기 (12.10), 슈퍼 클래스를 위임으로 바꾸기 (12.11)
    - 상속 구조에서 부모 자식 사이에 결탁이 생겼을 때.
    

# 20. 거대한 클래스

- 클래스 추출하기 (7.5)
    - 같은 컴포넌트에 모아두는 것이 합당해보이는 필드들을 선택
    - 한 클래스 안에서 접두어나 접미어가 같은 필드들
- 슈퍼클래스 추출하기 (12.8), 타입 코드를 서브클래스로 바꾸기(12.6)
- 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다
    - 그 클래스 안에서 자체적으로 중복을 제거
- 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살펴본다
    - 각각의 기능 그룹이 개별 클래스로 추출될 후보
- 클래스 추출하기 (7.5), 슈퍼클래스 추출하기 (12.8), 타입 코드를 서브클래스로 바꾸기 (12.6)

# 21. 서로 다른 인터페이스 대안 클래스들

- 클래스를 사용할 때의 가장 큰 장점은 필요에 따라 언제든 다른 클래수로 교체할 수 있다는 것.
    - 교체하려면 인터페이스가 같아야 한다.
- 함수 선언 바꾸기 (6.5)
    - 메서드 시그니처를 일치시킨다
- 함수 옮기기 (8.1)
    - 인터페이스가 같아 질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 슈퍼클래스 추출하기 (12.8)
    - 대안 클래스들 사이에 중복 코드가 생기면
    

# 22. 데이터 클래스

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
- 레코드 캡슐화하기 (7.1)
    - public 필드가 있다면, 숨겨야 함
- 세터 제거하기 (11.7)
    - 접근을 원천 봉쇄
- 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 함수 옮기기(8.1)로 그 메서드를 데이터 클래스로 옮길 수 있는지 살펴봐야 한다.
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼있다는 신호일 수 있다.
    - 클라이언트 코드를 데이터 클래스로 옮기기만 해도 개선된다.
- 하지만, 중간데이터 구조 (불변) 필드는 굳이 캡슐화할 필요 없다.

# 23. 상속 포기

- 부오의 메소드 중에서 몇개만 받고 끝내려는 경우
- 같은 계층에서 서브클래스를 하나 새로 만들고,
- 메서드 내리기 (12.4), 필드 내리기 (12.5)
    - 물려받지 않을 부모코드를 모조리 새로 만든 서브클래스로 옮긴다.
    - 부모에는 공통된 부분만 남는다.
- 부모의 동작은 필요로 하지만, 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
    - 서브클래스를 위임으로 바꾸기 (12.10), 슈퍼클래스를 위임으로 바꾸기 (12.11) 활용

# 24. 주석

- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많다.
- 코드 블록이 하는 일에 주석을 남기고 싶다면 함수 추출하기를 적용
- 이미 추출되어 있는 함수임에도 여전히 설명이 피리요하다면 함수 선언 바꾸기로 함수 이름을 바꿔본다.
- 시스템이 동작하기 위한 선행 조건을 명시하고 싶다면, 어서션 추가하기