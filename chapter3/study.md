## 3.1 기이한 이름

코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 이름이다. 그러나 이는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지 중 하나이다.

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅히 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드

## 3.3 긴 함수

오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다. 짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다. 하지만 프로그램을 수년 동안 다루다 보면 이 짧은 함수들이 얼마나 중요한지 깨닫게 된다. 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

요즘 언어는 프로그세스 안에서의 함수 호출 비용을 거의 없애 짧은 함수가 좋다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 하므로 여전히 부담이 된다. 하지만 **함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.**

그러긴 위해선 훨씬 적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다. 이렇게 함수로 묶는 코드는 여러 줄일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 무엇을 하는지를 코드가 잘 설명해주지 못할 수록 함수로 만드는 게 유리하다. 핵심은 길이가 아닌 목적(의도)이다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다. 이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 너무 많아져 리팩터링 전보다 난해해질 수 있다. 그럴 땐 `임시 변수를 질의 함수로 바꾸기`로 임시 변수의 수를 줄이고, `매개변수 객체 만들기`와 `객체 통째로 넘기기`로 매개변수의 수를 줄일 수 있다.

이 기법들을 사용해서 임시 변수와 매개변수가 너무 많다면 더 큰 수술인 `함수를 명령형으로 바꾸기`를 고려한다.

추출할 코드 덩어리를 찾는 좋은 방법 중 하나는 설명하는 주석이 적힌 부분을 참고하는 것이다. 함수 이름은 주석 내용을 토대로 짓는다. 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

조건문이나 반복문도 추출 대상의 실마리를 제공한다. `조건문은 분해`하고, switch문의 case문 마다 `함수 추출하기`를 적용해 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 `조건부 로직을 다형성으로` 바꾼다.

반복문도 그 안의 코드와 함께 추출해 독립된 함수로 바꾼다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다. 이럴 때는 과감히 반복문 쪼개기를 적용해 작업을 분리한다.

## 3.4 긴 매개변수 목록

매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 `매개변수를 질의 함수로 바꾸기`로 제거할 수 있다. 사용 중인 데이터 구조에서 값을을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 `객체 통째로 넘기기`를 적용해 원본 데이터 구조를 그대로 전달한다. 항상 함께 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어버린다. 함수의 동작을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애준다.

클래스를 활용하는 것도 좋다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다. 이럴 때는 `여러 함수를 클래스로 묶기`를 이용하여 공통의 값들을 클래스의 필드로 정의한다. fp일 경우 일련의 부분 적용 함수들을 생성한다.

## 3.5 전역 데이터

전역 데이터는 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다. 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는 게 문제다. 전역 데이터의 대포적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

이를 방지하기 위한 대표적인 리팩터링은 `변수 캡슐화하기`다. 다른 코드에서 오염 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터 수정 부분을 쉽게 찾고 접근을 통제할 수 있다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 줄이는 것도 좋다.

전역 데이터가 아주 조금만 있더라도 캡슐화하는 편이 좋다.

## 3.6 가변 데이터

데이터 변경은 예상치 못한 결과나 버그로 이어지는 경우가 많다.
(그렇다면 버그나 예상치 못한 결과가 있을 때 데이터를 변경하는 부분을 우선으로 보면 된다는 의미도 될 듯)

`변수 캡슐화하기`를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용해 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 그러기 위해 `문장 슬라이드하기`와 `함수 추출하기`를 이용해 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. API를 만들 때는 `질의 함수와 변경 함수 분리하기`를 활용해 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다. 가능한 한 `세터 제거하기`도 적용한다. 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.

값을 다른 곳에서 설정할 수 있는 가변 데이터의 경우 더 나쁘다. `파생 변수를 질의 함수로 바꾸기`를 사용한다.

변수 유효범위가 넓어지면 악효과가 생길 수 있으므로 `여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해 유효범위를 클래스나 변환으로 제한한다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 `참조를 값으로 바꾸기`를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 3.7 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙 (Single Responsibility Principle, SRP)이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 맥락이 다른 경우(ex. db 연동과 금융 상품 처리) 독립된 모듈로 분리해야 프로그래밍이 편하다.

## 3.8 산탄총 수술

뒤엉킨 변경과 비슷하면서 정반대다. 코드를 변경할 때마다 자잘하게 수정하는 클래스가 많을 때 필요하다. 변경할 부분이 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

이럴 때는 함께 변경되는 대상들을 `함수 옮기기`와 `필드 옮기기`로 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶`고, 데이터 구조를 변환하거나 보강하는 함수들은 `여러 함수를 변환 함수로 묶`는다. 이렇게 묶은 함수들의 출력 결과를 묶어 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용한다.

어설프게 분리된 로직을 `함수 인라인하기`나 `클래스 인라인하기` 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다. 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다. 사실 우리는 작은 함수와 클래스에 지나칠 정도로 집착하지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는 데 개의치 않는다.

## 3.9 기능 편애

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 나타나는 현상이다.

이는 함수 위치를 데이터 근처로 옮겨주면 해결할 수 있다. 어디로 옮길지 명확하지 않다면, 가장 많은 데이터를 포함한 모듈로 옮긴다. 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

물론 이 규칙을 거스르는 패턴도 있다. 그 때의 원칙은 '함께 변경할 대상을 한데 모으는 것'이다. 데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다. 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.

## 3.10 데이터 뭉치

데이터 항목들은 여러 곳에서 함께 뭉쳐다니는 모습을 흔히 볼 수 있다. 이럴 때는 다음과 같이 따로 묶어야 한다.

1. 필드 형태의 데이터 뭉치를 찾아 `클래스 추출하기`로 하나의 객체로 묶는다.
2. 메서드 시그니처에 있는 데이터 뭉치에서 `매개변수 객체 만들기`나 `객체 통째로 넘기기`를 활용해 매개변수 수를 줄인다.

데이터 뭉치인지 판별하려면 값 하나를 삭제했을 때, 나머지 데이터만으로 의미가 없다면 객체가 되길 원하는 데이터 뭉치라는 뜻이다.

간단한 레코드 구조가 아닌 클래스로 옮기는 것이 더 좋은 코드일 것이다.

## 3.11 기본형 집착

자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간)을 직접 정의하기 꺼리는 사람이 많다. 그래서 금액을 그냥 숫자형으로 계산하거나, 물리량을 게산할 때도 밀리미터나 인치 같은 단위로 무시하고, 범위도 if (a < upper && a > lower)처럼 처리하는 코드도 많다.

`기본형을 객체로 바꾸기`를 적용할 수도 있고, 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 `타입 코드를 서브클래스로 바꾸기`와 `조건부 로직을 다형성으로 바꾸기`를 차례로 적용한다.

자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치이므로 따라서 `클래스 추출하기`와 `매개변수 객체 만들기`를 이용한다.

## 3.12 반복되는 switch문

switch문은 중복될 때 문제가 된다. 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아 수정해야 하기 때문이다. switch문이라고 해서 무조건 나쁜건 아니고 다형성을 이용하면 잘 사용할 수 있다.

## 3.13 반복문

일급함수를 지원하는 언어의 경우 반복문을 파이프라인으로 바꾸기를 적용해 구식 반복문을 제거할 수 있다. filter, map 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소

본문 코드를 그대로 쓰는 것과 진배 없는 함수, 실질적으로 메서드가 하나뿐인 클래스, 등 구조가 필요 없는 경우가 있다. 이런 것들은 `함수 인라인하기`, `클래스 인라인하기`로 처리할 수 있다. 상속을 사용했다면 `계층 합치기`를 적용한다.

## 3.15 추측성 일반화

'나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 발생한다. 당장 걸리적거리는 코드는 눈앞에서 치워버리자.

하는 일이 거의 없는 추상 클래스는 `계층 합치기`로 제거한다. 쓸데없이 위임하는 코드는 `함수 인라인하기`나 `클래스 인라인하기`로 삭제한다. 본문에서 사용되지 않는 매개변수는 `함수 선언 바꾸기`로 없앤다. 나중에 다른 버전을 만들 때 필요할 거라는 생각에 추가했지만 한 번도 사용한 적 없는 매개변수도 이 기법으로 제거한다.

추측성 일반화는 테스트 코드 말고는 사용한 곳이 없는 함수나 클래스에서 흔히 볼 수 있다. 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 `죽은 코드 제거하기`로 날려버리자.

## 3.16 임시 필드

특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 이런 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.

이렇게 덩그러니 떨어져 있는 필드들을 발견하면 `클래스 추출하기`로 제 살 곳을 찾아준다. 그런 다음 `함수 옮기기`로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다. 또한 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데, `특이 케이스 추가하기`로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있다.

## 3.17 메시지 체인

다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 이런 코드들은 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

이 문제는 `위임 숨기기`로 해결한다. `함수 추출하기`로 결과 객체를 사용하는 코드를 따로 빼낸 다음 `함수 옮기기`로 그 체인을 숨길 수 있는지 살펴본다.

```jsx
managerName = aPerson.department.manager.name;
managerName = aPerson.department.managerName; // 관리자 객체(manager)의 존재를 숨김
managerName = aPerson.manager.name; // 부서 객체(department)의 존재를 숨김
managerName = aPerson.managerName; // 부서 객체와 관리자 객체 모두의 존재를 숨김
```

## 3.18 중개자

캡슐화 과정의 위임은 지나치면 문제가 된다. 예를 들어 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우 등이 그렇다. `중개자 제거하기`를 활용해 실제로 일을 하는 객체와 직접 소통하게 하자. 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.

## 3.19 내부자 거래

모듈 사이 데이터 거래가 많으면 결합도가 높으므로 좋지 않다. 따라서 그 양을 줄이고 투명하게 처리해야 한다.

은밀히 데이터를 주고받는 모듈은 `함수 옮기기`와 `필드 옮기기` 기법으로 사적으로 처리하는 부분을 줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 `위임 숨기기`를 이용해 다른 모듈이 중간자 역할을 하게 한다.

자식 클래스가 부모 클래스에서 벗어날 때는 `서브 클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용하자.

## 3.20 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

이럴 때는 `클래스 추출하기`로 같이 모으기 좋아보이는 필드들 일부를 묶는다. (ex. depositAmount와 depositCurrency) 접두어나 접미어가 같은 필드들을 살펴보는 것도 좋다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 클래스 추출 말고 `슈퍼클래스 추출하기`나 `타입 코드를 서브클래스로 바꾸기`를 적용하는 편이 더 슁울 것이다.

코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다. 가령 부분부분 상당량의 로직이 똑같은 100줄짜리 메서드 5개가 있다면 각각 공통 부분을 작은 메서드로 뽑아내자. 그러면 이전의 5개 메서드는 작은 메서드를 호출하는 코드 10줄이 될 것이다.

클라이언트들이 거대 클래스를 이용하는지 패턴을 파악해 그 클래스를 어떻게 쪼갤지 단서를 얻을 수도 있다.

1. 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다.
   - 이 때 각각으 ㅣ기능 그룹이 개별 클래스로 추출될 후보다.
2. 유용한 기능 그룹을 찾았다면 `클래스 추출하기`, `슈퍼클래스 추출하기`, `타입 코드를 서브클래스로 바꾸기` 등을 활용해 여러 클래스로 분리한다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

클래스의 장점은 필요에 따라 언제든 다른 클래스로 교체 가능하다는 점이다. 단, 교체하려면 인터페이스가 같아야 한다. 따라서 `함수 선언 바꾸기`로 메서드 시그니처를 일치시킨다. 때로는 이것으로 부족한데, 이럴 때는 `함수 옮기기`를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다. 그러다 대안 클래스들 사이에 중복 코드가 생기면 `슈퍼클래스 추출하기`를 적용할지 고려해본다.

## 3.22 데이터 클래스

데이터 클래스 : 데이터 필드와 게터/세터 메서드로만 구성된 클래스. 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊게 함부로 다룰 때가 많다. 만약 public 필드가 있다면 `레코드 캡슐화하기`로 숨긴다. 변경하면 안 되는 필드는 `세터 제거하기`로 접근을 막는다.

다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 `함수 옮기기`로 그 메서드를 데이터 클래스로 옮길 수 있는지 살펴보자. 메서드를 통째로 옮기기 어렵다면 `함수 추출하기`를 이용해 옮길 수 있는 부분만 메서드로 뽑아낸다.

데이터 클래스는 필요 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수도 있다. 이런 경우 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다. 물론 동작 코드를 넣을 이유가 없는 등 예외인 경우도 있다.

## 3.23 상속 포기

서브클래스에서 부모의 리소스 중 몇개만 받길 원하는 경우도 있다.

예전에는 계층구조를 잘못 설계했기 때문으로 봐서 같은 계층에 서브클래스를 하나 새로 만들고, `메서드 내리기`와 `필드 내리기`를 활용해 물려받지 않을 부모 코드를 전부 새로 만든 서브클래스로 넘겨 부모에 공통된 부분만 남겼다. 부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람도 많다.

하지만 항상 이렇게 해야 한다는 입장은 아니라 권하진 않는다. 무조건 바꿔야 할 건 아니기 때문이다.

서브클래스가 부모의 동작은 필요하지만 인터페이스는 따르고 싶지 않을 땐 바꿔야 한다. 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다. 이럴 때는 `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용해 아예 상속 메커니즘에서 벗어나보자.

## 3.24 주석

주석은 지울게 아니라 오히려 좋은 것이나. 문제는 안 좋은 코드를 주석으로 극복하려고 하는 것이다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를 적용해본다. 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 `함수 선언 바꾸기`로 함수 이름을 바꿔본다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `어서션 추가하기`가 대기하고 있다.

`주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.`

뭘 할지 모를 때라면 주석을 달아두면 좋다. 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석을 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다.
